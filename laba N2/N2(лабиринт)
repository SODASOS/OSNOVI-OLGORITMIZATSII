from collections import deque
#Импортируем класс deque из модуля collections. deque — это двусторонняя очередь, которая используется для реализации очереди в алгоритме BFS, позволяя быстро добавлять и удалять элементы.
def read_maze():
    R, C = map(int, input().split())
#Определяем функцию read_maze, которая читает размеры лабиринта.
#Вводится строка, содержащая два числа — количество строк R и количество столбцов C.
#map(int, input().split()) преобразует эти значения в целые числа.
    maze = []
    start = None
    end = None
#Создаём пустой список maze для хранения строк лабиринта.
#Инициализируем start и end как None. Они будут содержать координаты входа S и выхода F соответственно.
    for r in range(R):
        row = list(input())
        maze.append(row)
        for c in range(C):
            if row[c] == 'S':
                start = (r, c)
            elif row[c] == 'F':
                end = (r, c)
#Цикл по строкам лабиринта, от 0 до R-1.
#Внутри цикла:
#Читается строка с помощью input().
#list(input()) превращает строку в список символов для удобства обращения по индексам.
#Эта строка добавляется в список maze.
#Внутренний цикл по столбцам:
#Если текущий символ 'S' — запоминаем координаты как start.
#Если 'F' — запоминаем как end.
    return maze, start, end
#Возвращает лабиринт и координаты входа и выхода.
def bfs(maze, start, end):
    R, C = len(maze), len(maze[0])
#Определяет функцию поиска кратчайшего пути bfs.
#R — число строк, C — число столбцов.
    visited = [[False]*C for _ in range(R)]
    parent = [[None]*C for _ in range(R)]
#Создаются двумерные списки:
#visited — отслеживание посещённых клеток.
#parent — хранит информацию о предке каждой клетки для восстановления пути.
    directions = [(-1,0,'U'), (1,0,'D'), (0,-1,'L'), (0,1,'R')]
#Список возможных движений:
#(-1,0,'U') — вверх
#(1,0,'D') — вниз
#(0,-1,'L') — влево
#(0,1,'R') — вправо
#Каждая команда содержит изменение координат и символ движения.
    queue = deque()
    queue.append(start)
    visited[start[0]][start[1]] = True
#Создаётся очередь для BFS.
#В очередь добавляется стартовая клетка.
#Маркируем стартовую клетку как посещённую.

    while queue:
        r, c = queue.popleft()
#Пока очередь не пуста:
#Извлекается текущая клетка (r, c).
        if (r, c) == end:
            return parent
#Если достигнут выход, возвращаем таблицу parent для восстановления пути.
        for dr, dc, move in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < R and 0 <= nc < C:
                if not visited[nr][nc] and maze[nr][nc] != '#':
                    visited[nr][nc] = True
                    parent[nr][nc] = (r, c, move)
                    queue.append((nr, nc))
#Перебираем все возможные направления.
#Вычисляем новые координаты (nr, nc).
#Проверяем:
#что новые координаты внутри границ.
#что клетка не посещена и не является стеной '#'.
#Если условие выполнено:
#Помечаем клетку как посещённую.
#Записываем в parent откуда пришли и какое движение было сделано.
#Добавляем новую клетку в очередь.
    return None
#Если очередь опустела и выхода не найдено, возвращается None.

def reconstruct_path(parent, start, end):
    path_moves = []
    cur = end
    while cur != start:
        r, c, move = parent[cur[0]][cur[1]]
        path_moves.append(move)
        cur = (r, c)
    path_moves.reverse()
    return path_moves
#Восстановление пути по таблице parent.
#Начинаем с выхода end.
#Пока не достигли старт start:
#Получаем предка и движение.
#Добавляем движение в список path_moves.
#Переходим к предку.
#После цикла разворачиваем список движений, так как он собирается в обратном порядке.
#Возвращаем последовательность движений.

def main():
    maze, start, end = read_maze()
    if start is None or end is None:
        print(-1)
        return
    
    parent = bfs(maze, start, end)
    if parent is None:
        print(-1)
    else:
        path = reconstruct_path(parent, start, end)
        print(len(path))
        print(''.join(path))
#Основная функция:
#Читает лабиринт.
#Если вход или выход не найдены — выводит -1.
#Запускает BFS.
#Если путь не найден — выводит -1.
#Иначе:
#Восстанавливает путь.
#Выводит длину пути.
#Выводит последовательность движений в одну строку.

if __name__ == "__main__":
    main()
#Стандартный блок запуска программы
