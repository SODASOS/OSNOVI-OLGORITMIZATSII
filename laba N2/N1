# Стек (LIFO)------------------------------------------------------------------------------------------------------------------------------------------------------
class Stack:
#Объявление класса Stack — реализует структуру данных стек.
    def __init__(self):
#Конструктор класса — вызывается при создании объекта.
        self.max_size = 20
#Максимальный размер стека — 20 элементов.
        self.array = [0.0] * self.max_size
#Создает массив из 20 элементов, заполненный нулями, для хранения данных.
        self.top = -1
#Индекс вершины стека. -1 означает, что стек пуст.

    def push(self, x):
#Метод push — добавление элемента в стек,метод добавляет элемент x в стек/////////////////////////////////////////////////////////////////////////////////////
        if self.top < self.max_size - 1:
#Проверка, есть ли место для нового элемента (стек не переполнен)
            self.top += 1
#увеличиваем индекс вершины на 1
            self.array[self.top] = x
#Записываем элемент x в массив по новому индексу
        else:
            print("Ошибка: переполнение стека.")
#Если стек переполнен, выводится сообщение об ошибке

    def pop(self):
#Метод pop — удаление и возврат верхнего элемента,Удаляет и возвращает верхний элемент//////////////////////////////////////////////////////////////////////
        if self.top >= 0:
#Проверка, что стек не пуст (есть элементы)
            val = self.array[self.top]
#Запоминаем верхний элемент
            self.top -= 1
#Уменьшаем индекс вершины, удаляя элемент
            return val
#Возвращаем удаленный элемент
        else:
            print("Ошибка: стек пустой.")
            return None
#Если стек пуст, выводим сообщение и возвращаем None

    def peek(self):
#Метод peek — просмотр верхнего элемента без удаления,Возвращает верхний элемент без удаления///////////////////////////////////////////////////////////////////
        if self.top >= 0:
            return self.array[self.top]
        else:
            print("Ошибка: стек пустой.")
            return None
#Аналогично pop, только без изменения top

    def size(self):
        return self.top + 1
#Метод size — текущий размер стека,Размер равен top + 1, так как top — индекс последнего элемента///////////////////////////////////////////////////////////////
    def clear(self):
        self.top = -1
#Метод clear — очистка стека,Сбрасывает стек, делая его пустым/////////////////////////////////////////////////////////////////////////////////////////////////

    def print_contents(self):
        if self.top >= 0:
            print("Содержимое стека (от верхнего к нижнему):")
            for i in range(self.top, -1, -1):
                print(self.array[i])
        else:
            print("Стек пуст.")
#Метод print_contents — вывод содержимого стека.Если стек не пуст, выводит элементы от вершины к низу.Иначе сообщает, что стек пуст////////////////////////////

# Очередь (FIFO)--------------------------------------------------------------------------------------------------------------------------------------------------------------------
class Queue:
#Объявление класса очереди
    def __init__(self):
        self.max_size = 20
        self.array = [0.0] * self.max_size
        self.front_index = 0
        self.rear_index = 0
        self.count = 0
#Инициализация: создается массив из 20 элементов.
#front_index — индекс первого элемента.
#rear_index — индекс следующей свободной ячейки для добавления.
#count — текущее число элементов.

    def enqueue(self, x):
#Метод enqueue — добавление элемента в очередь////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if self.count < self.max_size:
            self.array[self.rear_index] = x
            self.rear_index = (self.rear_index + 1) % self.max_size
            self.count += 1
        else:
            print("Ошибка: очередь полная.")
#Проверка, есть ли место.
#Записываем элемент по rear_index.
#Смещаем rear_index вперед по кольцу (% self.max_size).
#Увеличиваем счетчик count.

    def dequeue(self):
#Метод dequeue — удаление элемента из очереди/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if self.count > 0:
            val = self.array[self.front_index]
            self.front_index = (self.front_index + 1) % self.max_size
            self.count -= 1
            return val
        else:
            print("Ошибка: очередь пуста.")
            return None
#Проверка, что очередь не пуста.
#Запоминаем первый элемент.
#Смещаем front_index по кольцу.
#Уменьшаем счетчик.
#Возвращаем элемент.

    def front(self):
#Метод front — просмотр первого элемента//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if self.count > 0:
            return self.array[self.front_index]
        else:
            print("Ошибка: очередь пуста.")
            return None
#Возвращает первый элемент без удаления

    def size(self):
#Метод size — текущий размер очереди/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        return self.count
#Возвращает количество элементов.

    def clear(self):
#Метод clear — очистка очереди///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        self.front_index = 0
        self.rear_index = 0
        self.count = 0
#Обнуляет индексы и счетчик

    def print_contents(self):
#Метод print_contents — вывод содержимого////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if self.count > 0:
            print("Содержимое очереди:")
            idx = self.front_index
            for _ in range(self.count):
                print(self.array[idx])
                idx = (idx + 1) % self.max_size
        else:
            print("Очередь пуста.")
#Проходит по очереди от front_index и выводит элементы.
#Использует кольцевой проход


# Минимальная двоичная куча (min-heap)-----------------------------------------------------------------------------------------------------------------------------------
class MinHeap:
#Объявление класса MinHeap
    def __init__(self):
        self.max_size = 20
        self.array = [0.0] * self.max_size
        self.size = 0
#Инициализация: массив для хранения элементов.
#size — текущий размер

    def insert(self, x):
#Метод insert — вставка элемента///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if self.size < self.max_size:
            self.array[self.size] = x
            self._heapify_up(self.size)
            self.size += 1
        else:
            print("Ошибка: куча полна.")
#Добавляет элемент в конец массива.
#Восстанавливает свойство кучи вверх (_heapify_up).
#Увеличивает размер.

    def extract_min(self):
#Метод extract_min — удаление минимального элемента/////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if self.size > 0:
            min_elem = self.array[0]
            self.size -= 1
            self.array[0] = self.array[self.size]
            self._heapify_down(0)
            return min_elem
        else:
            print("Ошибка: куча пуста.")
            return None
#Запоминает корень — минимум.
#Перемещает последний элемент в корень.
#Восстанавливает свойство кучи вниз (_heapify_down).
#Уменьшает размер

    def get_min(self):
#Метод get_min — просмотр минимума без удаления/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if self.size > 0:
            return self.array[0]
        else:
            print("Ошибка: куча пуста.")
            return None
#Возвращает корень

    def clear(self):
#Метод clear — очистка кучи////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        self.size = 0
#Обнуляет размер, куча становится пустой

    def print_heap(self):
#Метод print_heap — вывод массива кучи///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if self.size > 0:
            print("Массив кучи:", self.array[:self.size])
        else:
            print("Куча пуста.")
#Выводит текущие элементы

    def _heapify_up(self, index):
#Внутренние методы _heapify_up и _heapify_down//////////////////////////////////////////////////////////////////////////////////////////////////////////////
        while index > 0:
            parent = (index - 1) // 2
            if self.array[index] < self.array[parent]:
                self.array[index], self.array[parent] = self.array[parent], self.array[index]
                index = parent
            else:
                break
#Восстанавливает свойство кучи вверх, меняя местами с родителем, если значение меньше

    def _heapify_down(self, index):
        while True:
            left = 2 * index + 1
            right = 2 * index + 2
            smallest = index

            if left < self.size and self.array[left] < self.array[smallest]:
                smallest = left
            if right < self.size and self.array[right] < self.array[smallest]:
                smallest = right
            if smallest != index:
                self.array[index], self.array[smallest] = self.array[smallest], self.array[index]
                index = smallest
            else:
                break
#Восстанавливает свойство кучи вниз, меняя местами с меньшим из детей

# Пример использования
if __name__ == "__main__":
    # Работа со стеком
    print("=== Стек ===")
    stack = Stack()
    stack.push(10.5)
    stack.push(20.2)
    stack.print_contents()
    print("peek:", stack.peek())
    print("pop:", stack.pop())
    print("Размер:", stack.size())
    stack.print_contents()
    print()
#Создается стек.
#В него добавляются два элемента.
#Выводится содержимое.
#Просматривается вершина.
#Удаляется верхний элемент.
#Выводится размер и содержимое после операций.

    # Очередь
    print("=== Очередь ===")
    queue = Queue()
    queue.enqueue(5.5)
    queue.enqueue(15.15)
    queue.print_contents()
    print("front:", queue.front())
    print("dequeue:", queue.dequeue())
    print("Размер:", queue.size())
    queue.print_contents()
    print()
#Создается очередь.
#Добавляются два элемента.
#Выводится содержимое.
#Просматривается первый элемент.
#Удаляется первый элемент.
#Выводится размер и содержимое после операций.

    # Минимальная куча
    print("=== Минимальная куча ===")
    heap = MinHeap()
    heap.insert(30.0)
    heap.insert(10.0)
    heap.insert(20.0)
    heap.print_heap()
    print("Минимальный элемент:", heap.get_min())
    print("Извлечение минимума:", heap.extract_min())
    heap.print_heap()
    print("Размер:", heap.size)
#Создается куча.
#В нее добавляются три элемента.
#Выводится массив кучи.
#Просматривается минимум.
#Извлекается минимум.
#Выводится текущий массив и размер.
