1) Задача по алгоритму Дейкстры:
В графе с 6 вершинами (города A, B, C, D, E, F) заданы стоимости проезда между некоторыми городами: A-B=5, A-C=10, B-D=3, B-E=7, C-D=2, C-F=4, D-E=1, E-F=6. Отсутствующие ребра считать бесконечными. Оля живёт в городе A. Определите минимальную сумму, которую ей нужно потратить, чтобы посетить все остальные города (B, C, D, E, F), используя кратчайшие пути от A. Реализуйте алгоритм Дейкстры на и выведите каждую итерацию решения.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
using System;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        int INF = int.MaxValue;

        // Вершины
        string[] vertices = { "A", "B", "C", "D", "E", "F" };
        int n = vertices.Length;

        // Матрица расстояний (инициализация бесконечностью)
        int[,] graph = new int[n, n];

        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                graph[i, j] = INF;

        // Заданные ребра
        graph[0, 1] = 5;   // A-B
        graph[0, 2] = 10;  // A-C
        graph[1, 3] = 3;   // B-D
        graph[1, 4] = 7;   // B-E
        graph[2, 3] = 2;   // C-D
        graph[2, 5] = 4;   // C-F
        graph[3, 4] = 1;   // D-E
        graph[4, 5] = 6;   // E-F

        // Для неориентированного графа - симметрично
        graph[1, 0] = 5; graph[2, 0] = 10;
        graph[3, 1] = 3; graph[4, 1] = 7;
        graph[3, 2] = 2; graph[5, 2] = 4;
        graph[4, 3] = 1; graph[5, 4] = 6;

        // Алгоритм Дейкстры
        int[] dist = new int[n];
        bool[] visited = new bool[n];

        // Инициализация
        for (int i = 0; i < n; i++)
        {
            dist[i] = INF;
            visited[i] = false;
        }
        dist[0] = 0; // старт из A (индекс 0)

        Console.WriteLine("Итерации алгоритма Дейкстры:\n");

        for (int count = 0; count < n; count++)
        {
            // Выбор вершины с минимальным расстоянием, ещё не посещённой
            int u = -1;
            int minDist = INF;

            for (int i = 0; i < n; i++)
            {
                if (!visited[i] && dist[i] < minDist)
                {
                    minDist = dist[i];
                    u = i;
                }
            }

            if (u == -1)
                break; // все посещены или остались недостижимые вершины

            // Посетить вершину u
            visited[u] = true;

            // Вывод текущей итерации
            Console.WriteLine($"Итерация {count + 1}:");
            Console.WriteLine($"Выбрана вершина: {vertices[u]} (расстояние: {dist[u]})");
            Console.WriteLine("Обновляем соседей:");
            for (int v = 0; v < n; v++)
            {
                if (!visited[v] && graph[u, v] != INF)
                {
                    int newDist = dist[u] + graph[u, v];
                    if (newDist < dist[v])
                    {
                        Console.WriteLine($" - {vertices[v]}: обновление расстояния {dist[v]} -> {newDist}");
                        dist[v] = newDist;
                    }
                    else
                    {
                        Console.WriteLine($" - {vertices[v]}: расстояние не меняется ({dist[v]})");
                    }
                }
            }
            Console.WriteLine();
        }

        // Итоговые расстояния
        Console.WriteLine("Минимальные расстояния от A до остальных городов:");
        for (int i = 1; i < n; i++)
        {
            Console.WriteLine($"{vertices[0]} -> {vertices[i]}: {dist[i]}");
        }

        // Общая сумма
        int totalSum = 0;
        for (int i = 1; i < n; i++)
        {
            totalSum += dist[i];
        }
        Console.WriteLine($"\nМинимальная сумма, чтобы посетить все остальные города: {totalSum}");
    }
}  
